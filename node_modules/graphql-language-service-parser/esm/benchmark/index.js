import fs from 'fs';
import path from 'path';
import Benchmark from 'benchmark';
import { parse } from 'graphql';
import { onlineParser, CharacterStream } from '../';
const printResult = (stats, name, schema) => {
    console.log({
        name,
        mean: `${1.0 / stats.mean} ops / sec`,
        variance: stats.variance,
        rme: `${stats.rme}%`,
        lines: schema.split('\n').length,
    });
    console.log(`Completed test suite: ${name}`);
};
const runSplitTest = (name, schema) => {
    const stats = [];
    const suite = new Benchmark.Suite();
    const parser = onlineParser();
    let state = parser.startState();
    schema.split('\n').forEach((line, index) => {
        let prevState;
        let completeState;
        suite.add({
            maxTime: 0.1,
            onStart: () => {
                prevState = Object.assign({}, state);
            },
            fn: () => {
                const stream = new CharacterStream(line);
                while (!stream.eol()) {
                    parser.token(stream, state);
                    if (state.kind === 'Invalid') {
                        console.log(state.kind, line, index);
                        throw new Error('Invalid');
                    }
                }
                completeState = state;
                state = Object.assign({}, prevState);
            },
            onError: console.log,
            onComplete: (e) => {
                state = completeState;
                stats.push(e.target.stats);
            },
        });
    });
    console.log(`Started test suite: ${name}`);
    suite.run();
    const results = stats.reduce((result, stat) => {
        result.mean += stat.mean / stats.length;
        result.rme += stat.rme / stats.length;
        result.variance += stat.variance / stats.length;
        return result;
    }, { mean: 0, variance: 0, rme: 0 });
    printResult(results, name, schema);
};
const runWholeTest = (name, schema) => {
    const suite = new Benchmark.Suite('', {
        onComplete: (e) => printResult(e.target.stats, name, schema),
    });
    const parser = onlineParser();
    const state = parser.startState();
    suite.add(() => {
        const stream = new CharacterStream(schema);
        while (!stream.eol()) {
            parser.token(stream, state);
            if (state.kind === 'Invalid') {
                console.log(state.kind);
                throw new Error('Invalid');
            }
        }
    });
    console.log(`Started test suite: ${name}`);
    suite.run();
};
const runGraphqlParserTest = (name, schema) => {
    const suite = new Benchmark.Suite('', {
        onComplete: (e) => printResult(e.target.stats, name, schema),
    });
    suite.add({
        fn() {
            try {
                parse(schema);
            }
            catch (err) {
                console.log(err);
                throw err;
            }
        },
    });
    console.log(`Started test suite: ${name}`);
    suite.run();
};
const kitchenSchema = fs.readFileSync(path.resolve(__dirname, './fixtures/kitchen-sink.graphql'), {
    encoding: 'utf8',
});
const githubSchema = fs.readFileSync(path.resolve(__dirname, './fixtures/github.graphql'), {
    encoding: 'utf8',
});
runWholeTest('kitchen-sink:whole', kitchenSchema);
runSplitTest('kitchen-sink:split', kitchenSchema);
runWholeTest('github:whole', githubSchema);
runGraphqlParserTest('kitchen-sink:graphqljs', kitchenSchema);
runGraphqlParserTest('github:graphqljs', githubSchema);
//# sourceMappingURL=index.js.map