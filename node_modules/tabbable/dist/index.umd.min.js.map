{"version":3,"file":"index.umd.min.js","sources":["../src/index.js"],"sourcesContent":["let candidateSelectors = [\n  'input',\n  'select',\n  'textarea',\n  'a[href]',\n  'button',\n  '[tabindex]',\n  'audio[controls]',\n  'video[controls]',\n  '[contenteditable]:not([contenteditable=\"false\"])',\n  'details>summary',\n];\nlet candidateSelector = /* #__PURE__ */ candidateSelectors.join(',');\n\nlet matches =\n  typeof Element === 'undefined'\n    ? function () {}\n    : Element.prototype.matches ||\n      Element.prototype.msMatchesSelector ||\n      Element.prototype.webkitMatchesSelector;\n\nfunction tabbable(el, options) {\n  options = options || {};\n\n  let regularTabbables = [];\n  let orderedTabbables = [];\n\n  let candidates = getCandidates(\n    el,\n    options.includeContainer,\n    isNodeMatchingSelectorTabbable\n  );\n\n  candidates.forEach(function (candidate, i) {\n    let candidateTabindex = getTabindex(candidate);\n    if (candidateTabindex === 0) {\n      regularTabbables.push(candidate);\n    } else {\n      orderedTabbables.push({\n        documentOrder: i,\n        tabIndex: candidateTabindex,\n        node: candidate,\n      });\n    }\n  });\n\n  let tabbableNodes = orderedTabbables\n    .sort(sortOrderedTabbables)\n    .map((a) => a.node)\n    .concat(regularTabbables);\n\n  return tabbableNodes;\n}\n\nfunction focusable(el, options) {\n  options = options || {};\n\n  let candidates = getCandidates(\n    el,\n    options.includeContainer,\n    isNodeMatchingSelectorFocusable\n  );\n\n  return candidates;\n}\n\nfunction getCandidates(el, includeContainer, filter) {\n  let candidates = Array.prototype.slice.apply(\n    el.querySelectorAll(candidateSelector)\n  );\n  if (includeContainer && matches.call(el, candidateSelector)) {\n    candidates.unshift(el);\n  }\n  candidates = candidates.filter(filter);\n  return candidates;\n}\n\nfunction isNodeMatchingSelectorTabbable(node) {\n  if (\n    !isNodeMatchingSelectorFocusable(node) ||\n    isNonTabbableRadio(node) ||\n    getTabindex(node) < 0\n  ) {\n    return false;\n  }\n  return true;\n}\n\nfunction isTabbable(node) {\n  if (!node) {\n    throw new Error('No node provided');\n  }\n  if (matches.call(node, candidateSelector) === false) {\n    return false;\n  }\n  return isNodeMatchingSelectorTabbable(node);\n}\n\nfunction isNodeMatchingSelectorFocusable(node) {\n  if (node.disabled || isHiddenInput(node) || isHidden(node)) {\n    return false;\n  }\n  return true;\n}\n\nlet focusableCandidateSelector = /* #__PURE__ */ candidateSelectors\n  .concat('iframe')\n  .join(',');\nfunction isFocusable(node) {\n  if (!node) {\n    throw new Error('No node provided');\n  }\n  if (matches.call(node, focusableCandidateSelector) === false) {\n    return false;\n  }\n  return isNodeMatchingSelectorFocusable(node);\n}\n\nfunction getTabindex(node) {\n  let tabindexAttr = parseInt(node.getAttribute('tabindex'), 10);\n\n  if (!isNaN(tabindexAttr)) {\n    return tabindexAttr;\n  }\n\n  // Browsers do not return `tabIndex` correctly for contentEditable nodes;\n  // so if they don't have a tabindex attribute specifically set, assume it's 0.\n  if (isContentEditable(node)) {\n    return 0;\n  }\n\n  // in Chrome, <audio controls/> and <video controls/> elements get a default\n  //  `tabIndex` of -1 when the 'tabindex' attribute isn't specified in the DOM,\n  //  yet they are still part of the regular tab order; in FF, they get a default\n  //  `tabIndex` of 0; since Chrome still puts those elements in the regular tab\n  //  order, consider their tab index to be 0\n  if (\n    (node.nodeName === 'AUDIO' || node.nodeName === 'VIDEO') &&\n    node.getAttribute('tabindex') === null\n  ) {\n    return 0;\n  }\n\n  return node.tabIndex;\n}\n\nfunction sortOrderedTabbables(a, b) {\n  return a.tabIndex === b.tabIndex\n    ? a.documentOrder - b.documentOrder\n    : a.tabIndex - b.tabIndex;\n}\n\nfunction isContentEditable(node) {\n  return node.contentEditable === 'true';\n}\n\nfunction isInput(node) {\n  return node.tagName === 'INPUT';\n}\n\nfunction isHiddenInput(node) {\n  return isInput(node) && node.type === 'hidden';\n}\n\nfunction isRadio(node) {\n  return isInput(node) && node.type === 'radio';\n}\n\nfunction isNonTabbableRadio(node) {\n  return isRadio(node) && !isTabbableRadio(node);\n}\n\nfunction getCheckedRadio(nodes, form) {\n  for (let i = 0; i < nodes.length; i++) {\n    if (nodes[i].checked && nodes[i].form === form) {\n      return nodes[i];\n    }\n  }\n}\n\nfunction isTabbableRadio(node) {\n  if (!node.name) {\n    return true;\n  }\n  const radioScope = node.form || node.ownerDocument;\n  let radioSet = radioScope.querySelectorAll(\n    'input[type=\"radio\"][name=\"' + node.name + '\"]'\n  );\n  let checked = getCheckedRadio(radioSet, node.form);\n  return !checked || checked === node;\n}\n\nfunction isHidden(node) {\n  if (getComputedStyle(node).visibility === 'hidden') return true;\n\n  while (node) {\n    if (getComputedStyle(node).display === 'none') return true;\n    node = node.parentElement;\n  }\n\n  return false;\n}\n\nexport { tabbable, focusable, isTabbable, isFocusable };\n"],"names":["candidateSelectors","candidateSelector","join","matches","Element","prototype","msMatchesSelector","webkitMatchesSelector","getCandidates","el","includeContainer","filter","candidates","Array","slice","apply","querySelectorAll","call","unshift","isNodeMatchingSelectorTabbable","node","isNodeMatchingSelectorFocusable","isInput","type","isRadio","name","checked","nodes","form","i","length","getCheckedRadio","ownerDocument","isTabbableRadio","isNonTabbableRadio","getTabindex","disabled","isHiddenInput","getComputedStyle","visibility","display","parentElement","isHidden","focusableCandidateSelector","concat","tabindexAttr","parseInt","getAttribute","isNaN","contentEditable","isContentEditable","nodeName","tabIndex","sortOrderedTabbables","a","b","documentOrder","tagName","options","Error","regularTabbables","orderedTabbables","forEach","candidate","candidateTabindex","push","sort","map"],"mappings":";;;;oUAAA,IAAIA,EAAqB,CACvB,QACA,SACA,WACA,UACA,SACA,aACA,kBACA,kBACA,mDACA,mBAEEC,EAAoCD,EAAmBE,KAAK,KAE5DC,EACiB,oBAAZC,QACH,aACAA,QAAQC,UAAUF,SAClBC,QAAQC,UAAUC,mBAClBF,QAAQC,UAAUE,sBA+CxB,SAASC,EAAcC,EAAIC,EAAkBC,OACvCC,EAAaC,MAAMR,UAAUS,MAAMC,MACrCN,EAAGO,iBAAiBf,WAElBS,GAAoBP,EAAQc,KAAKR,EAAIR,IACvCW,EAAWM,QAAQT,GAErBG,EAAaA,EAAWD,OAAOA,GAIjC,SAASQ,EAA+BC,YAEnCC,EAAgCD,IAyFrC,SAA4BA,UAJ5B,SAAiBA,UACRE,EAAQF,IAAuB,UAAdA,EAAKG,KAItBC,CAAQJ,KAWjB,SAAyBA,OAClBA,EAAKK,YACD,MAMLC,EAhBN,SAAyBC,EAAOC,OACzB,IAAIC,EAAI,EAAGA,EAAIF,EAAMG,OAAQD,OAC5BF,EAAME,GAAGH,SAAWC,EAAME,GAAGD,OAASA,SACjCD,EAAME,GAaHE,EAJKX,EAAKQ,MAAQR,EAAKY,eACXhB,iBACxB,6BAA+BI,EAAKK,KAAO,MAELL,EAAKQ,aACrCF,GAAWA,IAAYN,EApBNa,CAAgBb,GAzFvCc,CAAmBd,IACnBe,EAAYf,GAAQ,GAiBxB,SAASC,EAAgCD,WACnCA,EAAKgB,UA6DX,SAAuBhB,UACdE,EAAQF,IAAuB,WAAdA,EAAKG,KA9DRc,CAAcjB,IA6FrC,SAAkBA,MAC0B,WAAtCkB,iBAAiBlB,GAAMmB,WAAyB,OAAO,OAEpDnB,GAAM,IAC4B,SAAnCkB,iBAAiBlB,GAAMoB,QAAoB,OAAO,EACtDpB,EAAOA,EAAKqB,qBAGP,EArGqCC,CAAStB,IAMvD,IAAIuB,EAA6C3C,EAC9C4C,OAAO,UACP1C,KAAK,KAWR,SAASiC,EAAYf,OACfyB,EAAeC,SAAS1B,EAAK2B,aAAa,YAAa,WAEtDC,MAAMH,GA+Bb,SAA2BzB,SACO,SAAzBA,EAAK6B,gBA1BRC,CAAkB9B,GACb,EASY,UAAlBA,EAAK+B,UAA0C,UAAlB/B,EAAK+B,UACD,OAAlC/B,EAAK2B,aAAa,YAKb3B,EAAKgC,SAHH,EAlBAP,EAwBX,SAASQ,EAAqBC,EAAGC,UACxBD,EAAEF,WAAaG,EAAEH,SACpBE,EAAEE,cAAgBD,EAAEC,cACpBF,EAAEF,SAAWG,EAAEH,SAOrB,SAAS9B,EAAQF,SACS,UAAjBA,EAAKqC,oBAvGd,SAAmBhD,EAAIiD,UAGJlD,EACfC,GAHFiD,EAAUA,GAAW,IAIXhD,iBACRW,kBAgDJ,SAAqBD,OACdA,QACG,IAAIuC,MAAM,2BAEqC,IAAnDxD,EAAQc,KAAKG,EAAMuB,IAGhBtB,EAAgCD,iBA3BzC,SAAoBA,OACbA,QACG,IAAIuC,MAAM,2BAE4B,IAA1CxD,EAAQc,KAAKG,EAAMnB,IAGhBkB,EAA+BC,eA1ExC,SAAkBX,EAAIiD,OAGhBE,EAAmB,GACnBC,EAAmB,UAENrD,EACfC,GANFiD,EAAUA,GAAW,IAOXhD,iBACRS,GAGS2C,SAAQ,SAAUC,EAAWlC,OAClCmC,EAAoB7B,EAAY4B,GACV,IAAtBC,EACFJ,EAAiBK,KAAKF,GAEtBF,EAAiBI,KAAK,CACpBT,cAAe3B,EACfuB,SAAUY,EACV5C,KAAM2C,OAKQF,EACjBK,KAAKb,GACLc,KAAI,SAACb,UAAMA,EAAElC,QACbwB,OAAOgB"}